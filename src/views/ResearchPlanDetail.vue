<template>
  <div class="min-h-screen bg-gray-50 flex flex-col">
    <!-- 顶部导航栏 -->
    <nav class="bg-white shadow-sm">
      <div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
        <div class="flex justify-between items-center h-16">
          <div class="flex items-center space-x-8">
            <button
              @click="router.push('/')"
              class="text-gray-600 hover:text-gray-900 flex items-center"
            >
              <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 mr-1" viewBox="0 0 20 20" fill="currentColor">
                <path d="M10.707 2.293a1 1 0 00-1.414 0l-7 7a1 1 0 001.414 1.414L4 10.414V17a1 1 0 001 1h2a1 1 0 001-1v-2a1 1 0 011-1h2a1 1 0 011 1v2a1 1 0 001 1h2a1 1 0 001-1v-6.586l.293.293a1 1 0 001.414-1.414l-7-7z" />
              </svg>
              首页
            </button>
            <h1 class="text-2xl font-bold text-gray-900">MethodMate</h1>
            <div class="flex space-x-4">
              <button
                @click="router.push('/papers')"
                class="px-4 py-2 text-gray-600 hover:text-gray-900 font-medium"
                :class="{ 'text-purple-600 border-b-2 border-purple-600': currentSection === 'papers' }"
              >
                相关文献
              </button>
              <button
                @click="router.push('/research-plan')"
                class="px-4 py-2 text-gray-600 hover:text-gray-900 font-medium"
                :class="{ 'text-purple-600 border-b-2 border-purple-600': currentSection === 'research-plan' }"
              >
                定量研究方案
              </button>
            </div>
          </div>
          <div class="flex items-center space-x-4">
            <button
              @click="router.push('/references')"
              class="px-4 py-2 bg-purple-100 text-purple-700 rounded-lg hover:bg-purple-200 transition-colors flex items-center"
            >
              <svg class="w-4 h-4 mr-2" fill="currentColor" viewBox="0 0 20 20">
                <path fill-rule="evenodd" d="M3.172 5.172a4 4 0 015.656 0L10 6.343l1.172-1.171a4 4 0 115.656 5.656L10 17.657l-6.828-6.829a4 4 0 010-5.656z" clip-rule="evenodd"/>
              </svg>
              引用文献 ({{ papersState.referencedPapers.size }})
            </button>
            <button
              @click="router.push('/scholar-search')"
              class="px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 transition-colors"
            >
              文献搜索
            </button>
            <button
              @click="router.push('/history-plans')"
              class="px-4 py-2 bg-white text-purple-600 border border-purple-600 rounded-lg hover:bg-purple-50 transition-colors"
            >
              历史方案
            </button>
          </div>
        </div>
      </div>
    </nav>

    <main class="flex-1 max-w-[90rem] mx-auto px-4 sm:px-6 lg:px-8 py-8">
      <div class="grid grid-cols-12 gap-8">
        <!-- 左侧聊天框 -->
        <div class="col-span-4 h-[calc(100vh-8rem)]">
          <ChatBox ref="chatBoxRef" pageContext="research-plan" />
          
          <!-- 生成研究方案按钮 -->
          <div class="mt-4">
            <button
              @click="generateResearchPlan"
              :disabled="isGenerating"
              class="w-full px-4 py-3 bg-purple-600 text-white rounded-lg hover:bg-purple-700 transition-colors disabled:opacity-50 disabled:cursor-not-allowed flex items-center justify-center space-x-2"
            >
              <svg v-if="isGenerating" class="animate-spin h-5 w-5" fill="none" viewBox="0 0 24 24">
                <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
              </svg>
              <svg v-else class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5H7a2 2 0 00-2 2v10a2 2 0 002 2h8a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2m-3 7h3m-3 4h3m-6-4h.01M9 16h.01"/>
              </svg>
              <span>{{ isGenerating ? '生成中...' : '生成定量研究方案' }}</span>
            </button>
            
            <!-- 参考文献状态显示 -->
            <div class="mt-3 text-sm text-center">
              <!-- 生成状态提示 -->
              <div v-if="isGenerating" class="text-blue-600 mb-2">
                <svg class="w-4 h-4 inline mr-1 animate-spin" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15"/>
                </svg>
                正在等待智能体回复，请稍候...
              </div>
              
              <div v-if="papersState.referencedPapers.size > 0" class="text-purple-600">
                <svg class="w-4 h-4 inline mr-1" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z"/>
                </svg>
                已选择 {{ papersState.referencedPapers.size }} 篇参考文献
              </div>
              <div v-else class="text-gray-500">
                <svg class="w-4 h-4 inline mr-1" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"/>
                </svg>
                暂无参考文献（可在相关文献页面选择）
              </div>
            </div>
          </div>
        </div>

        <!-- 研究方案详情 -->
        <div class="col-span-8">
          <!-- 
            右侧显示的是当前方案：
            - 如果用户生成了AI方案，显示AI生成的内容
            - 如果用户正在查看历史方案，显示历史方案的内容
            - 如果没有生成方案，显示默认的示例内容
            - 用户在左侧聊天框发送消息时，当前方案会作为上下文发送给AI（但不显示在对话框中）
          -->
          <!-- 历史方案查看提示 -->
          <div v-if="isViewingHistoryPlan && historyState.currentViewingPlan" 
               class="bg-blue-50 border border-blue-200 rounded-lg p-4 mb-6">
            <div class="flex items-center justify-between">
              <div class="flex items-center space-x-3">
                <svg class="w-5 h-5 text-blue-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"/>
                </svg>
                <div>
                  <h4 class="text-sm font-medium text-blue-900">正在查看历史方案</h4>
                  <p class="text-sm text-blue-700">{{ historyState.currentViewingPlan.title }}</p>
                  <p class="text-xs text-blue-600">创建时间：{{ historyState.currentViewingPlan.createdAt }}</p>
                </div>
              </div>
              <div class="flex items-center space-x-3">
                <button 
                  @click="applyHistoryPlan"
                  class="px-4 py-2 bg-purple-600 text-white rounded-lg hover:bg-purple-700 transition-colors text-sm"
                >
                  应用此方案
                </button>
                <button 
                  @click="exitHistoryView"
                  class="px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 transition-colors text-sm"
                >
                  返回当前方案
                </button>
              </div>
            </div>
          </div>

          <div class="bg-white rounded-xl shadow-sm p-8">
            <div class="space-y-8">
              <!-- 实验方案部分 -->
              <div class="bg-white rounded-xl shadow-sm p-8">
                <!-- 方案导航按钮 -->
                <div class="flex space-x-4 mb-8">
                  <button
                    v-for="section in sections"
                    :key="section.id"
                    @click="activeSection = section.id"
                    class="px-4 py-2 rounded-lg font-medium transition-colors"
                    :class="[
                      activeSection === section.id
                        ? 'bg-purple-100 text-purple-700'
                        : 'text-gray-600 hover:bg-gray-100'
                    ]"
                  >
                    {{ section.name }}
                  </button>
                </div>

                <!-- 各部分内容 -->
                <div v-if="activeSection === 'full'">
                  <h2 class="text-2xl font-bold text-gray-900 mb-6">{{ hasGeneratedPlan ? currentPlanState.title : '定量研究方案' }}</h2>
                  <div class="space-y-6">
                    <!-- 如果有解析的plan数据，显示四个字段的内容 -->
                    <div v-if="hasGeneratedPlan">
                      <div v-if="currentPlanState.hypotheses && currentPlanState.hypotheses.length > 0">
                        <h3 class="text-lg font-semibold text-gray-900 mb-3">研究假设</h3>
                        <div class="space-y-2">
                          <div v-for="(hypothesis, index) in renderedHypotheses" :key="index" 
                               class="p-4 bg-gray-50 rounded-lg">
                            <div class="text-gray-900 prose prose-sm max-w-none" v-html="hypothesis"></div>
                          </div>
                        </div>
                      </div>
                      
                      <div v-if="currentPlanState.experimentalDesign">
                        <h3 class="text-lg font-semibold text-gray-900 mb-3">实验设计</h3>
                        <div class="text-gray-600 leading-relaxed prose prose-sm max-w-none" v-html="renderedExperimentalDesign"></div>
                      </div>
                      
                      <div v-if="currentPlanState.analysisMethod">
                        <h3 class="text-lg font-semibold text-gray-900 mb-3">数据分析</h3>
                        <div class="text-gray-600 leading-relaxed prose prose-sm max-w-none" v-html="renderedAnalysisMethod"></div>
                      </div>
                      
                      <div v-if="currentPlanState.expectedResults">
                        <h3 class="text-lg font-semibold text-gray-900 mb-3">结果呈现</h3>
                        <div class="text-gray-600 leading-relaxed prose prose-sm max-w-none" v-html="renderedExpectedResults"></div>
                      </div>
                    </div>
                    
                    <!-- 未生成方案时的提示 -->
                    <div v-else class="text-center py-16">
                      <div class="mb-6">
                        <svg class="mx-auto h-16 w-16 text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="1" d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z"/>
                        </svg>
                      </div>
                      <h3 class="text-lg font-medium text-gray-900 mb-2">还未生成实验方案，请先生成研究方案</h3>
                      <p class="text-gray-500 mb-6 max-w-md mx-auto">
                        您可以点击左侧的"生成定量研究方案"按钮，或在聊天框中输入相关需求来生成个性化的研究方案。
                      </p>
                      <div class="flex justify-center space-x-4 text-sm text-gray-400">
                        <div class="flex items-center">
                          <svg class="w-4 h-4 mr-1" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 10V3L4 14h7v7l9-11h-7z"/>
                          </svg>
                          智能生成
                        </div>
                        <div class="flex items-center">
                          <svg class="w-4 h-4 mr-1" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 6.253v13m0-13C10.832 5.477 9.246 5 7.5 5S4.168 5.477 3 6.253v13C4.168 18.477 5.754 18 7.5 18s3.332.477 4.5 1.253m0-13C13.168 5.477 14.754 5 16.5 5c1.746 0 3.332.477 4.5 1.253v13C20.832 18.477 19.246 18 17.5 18c-1.746 0-3.332.477-4.5 1.253"/>
                          </svg>
                          基于文献
                        </div>
                        <div class="flex items-center">
                          <svg class="w-4 h-4 mr-1" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 19v-6a2 2 0 00-2-2H5a2 2 0 00-2 2v6a2 2 0 002 2h2a2 2 0 002-2zm0 0V9a2 2 0 012-2h2a2 2 0 012 2v10m-6 0a2 2 0 002 2h2a2 2 0 002-2m0 0V5a2 2 0 012-2h2a2 2 0 012 2v14a2 2 0 01-2 2h-2a2 2 0 01-2-2z"/>
                          </svg>
                          结构化输出
                        </div>
                      </div>
                    </div>
                  </div>
                </div>
                <div v-if="activeSection === 'hypothesis'">
                  <h2 class="text-2xl font-bold text-gray-900 mb-6">研究假设</h2>
                  <div v-if="hasGeneratedPlan && currentPlanState.hypotheses && currentPlanState.hypotheses.length > 0" class="space-y-4">
                    <div v-for="(hypothesis, index) in renderedHypotheses" :key="index" 
                         class="p-4 bg-gray-50 rounded-lg">
                      <div class="text-gray-900 prose prose-sm max-w-none" v-html="hypothesis"></div>
                    </div>
                  </div>
                  <div v-else class="text-center py-12">
                    <div class="mb-4">
                      <svg class="mx-auto h-12 w-12 text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="1" d="M9.663 17h4.673M12 3v1m6.364 1.636l-.707.707M21 12h-1M4 12H3m3.343-5.657l-.707-.707m2.828 9.9a5 5 0 117.072 0l-.548.547A3.374 3.374 0 0014 18.469V19a2 2 0 11-4 0v-.531c0-.895-.356-1.754-.988-2.386l-.548-.547z"/>
                      </svg>
                    </div>
                    <p class="text-gray-500">还未生成实验方案，请先生成研究方案</p>
                  </div>
                </div>
                <div v-if="activeSection === 'design'">
                  <h2 class="text-2xl font-bold text-gray-900 mb-6">实验设计</h2>
                  <div v-if="hasGeneratedPlan && currentPlanState.experimentalDesign" class="space-y-6">
                    <div>
                      <div class="text-gray-600 leading-relaxed prose prose-sm max-w-none" v-html="renderedExperimentalDesign"></div>
                    </div>
                  </div>
                  <div v-else class="text-center py-12">
                    <div class="mb-4">
                      <svg class="mx-auto h-12 w-12 text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="1" d="M19.428 15.428a2 2 0 00-1.022-.547l-2.387-.477a6 6 0 00-3.86.517l-.318.158a6 6 0 01-3.86.517L6.05 15.21a2 2 0 00-1.806.547M8 4h8l-1 1v5.172a2 2 0 00.586 1.414l5 5c1.26 1.26.367 3.414-1.415 3.414H4.828c-1.782 0-2.674-2.154-1.414-3.414l5-5A2 2 0 009 10.172V5L8 4z"/>
                      </svg>
                    </div>
                    <p class="text-gray-500">还未生成实验方案，请先生成研究方案</p>
                  </div>
                </div>
                <div v-if="activeSection === 'analysis'">
                  <h2 class="text-2xl font-bold text-gray-900 mb-6">数据分析</h2>
                  <div v-if="hasGeneratedPlan && currentPlanState.analysisMethod" class="space-y-6">
                    <div>
                      <div class="text-gray-600 leading-relaxed prose prose-sm max-w-none" v-html="renderedAnalysisMethod"></div>
                    </div>
                  </div>
                  <div v-else class="text-center py-12">
                    <div class="mb-4">
                      <svg class="mx-auto h-12 w-12 text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="1" d="M9 19v-6a2 2 0 00-2-2H5a2 2 0 00-2 2v6a2 2 0 002 2h2a2 2 0 002-2zm0 0V9a2 2 0 012-2h2a2 2 0 012 2v10m-6 0a2 2 0 002 2h2a2 2 0 002-2m0 0V5a2 2 0 012-2h2a2 2 0 012 2v14a2 2 0 01-2 2h-2a2 2 0 01-2-2z"/>
                      </svg>
                    </div>
                    <p class="text-gray-500">还未生成实验方案，请先生成研究方案</p>
                  </div>
                </div>
                <div v-if="activeSection === 'results'">
                  <h2 class="text-2xl font-bold text-gray-900 mb-6">结果呈现</h2>
                  <div v-if="hasGeneratedPlan && currentPlanState.expectedResults" class="space-y-6">
                    <div>
                      <div class="text-gray-600 leading-relaxed prose prose-sm max-w-none" v-html="renderedExpectedResults"></div>
                    </div>
                  </div>
                  <div v-else class="text-center py-12">
                    <div class="mb-4">
                      <svg class="mx-auto h-12 w-12 text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="1" d="M7 12l3-3 3 3 4-4M8 21l4-4 4 4M3 4h18M4 4h16v12a1 1 0 01-1 1H5a1 1 0 01-1-1V4z"/>
                      </svg>
                    </div>
                    <p class="text-gray-500">还未生成实验方案，请先生成研究方案</p>
                  </div>
                </div>
              </div>

              <!-- 方案评估和迭代按钮 -->
              <div v-if="hasGeneratedPlan" class="bg-white rounded-xl shadow-sm p-4 mb-4">
                <div class="flex justify-end space-x-4">
                  <button
                    @click="evaluatePlan"
                    class="px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 transition-colors flex items-center space-x-2"
                  >
                    <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                      <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z"/>
                    </svg>
                    <span>评估方案</span>
                  </button>
                  <button
                    @click="iteratePlan"
                    class="px-4 py-2 bg-green-600 text-white rounded-lg hover:bg-green-700 transition-colors flex items-center space-x-2"
                  >
                    <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                      <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15"/>
                    </svg>
                    <span>方案迭代</span>
                  </button>
                </div>
              </div>

              <!-- 来源和方法介绍卡片 -->
              <div class="bg-white rounded-xl shadow-sm p-8">
                <!-- 来源介绍内容（只显示研究假设、实验设计、结果呈现） -->
                <div v-if="['hypothesis', 'design', 'results'].includes(activeSection)" class="space-y-4">
                  <div class="flex items-center justify-between mb-3">
                    <h3 class="text-lg font-semibold text-gray-900">来源介绍</h3>
                    <button
                      @click="generateSourceIntroduction"
                      :disabled="isGeneratingSource"
                      class="px-3 py-1 text-sm bg-purple-100 text-purple-700 rounded-lg hover:bg-purple-200 transition-colors disabled:opacity-50 disabled:cursor-not-allowed flex items-center space-x-1"
                    >
                      <svg v-if="isGeneratingSource" class="animate-spin h-4 w-4" fill="none" viewBox="0 0 24 24">
                        <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                        <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                      </svg>
                      <svg v-else class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15"/>
                      </svg>
                      <span>{{ isGeneratingSource ? '生成中...' : '生成来源介绍' }}</span>
                    </button>
                  </div>
                  <div v-if="currentSourceIntroduction" class="text-gray-600 leading-relaxed prose prose-sm max-w-none" v-html="renderedSourceIntroduction"></div>
                  <div v-else class="text-gray-500 italic">
                    点击"生成来源介绍"按钮，基于参考文献生成当前部分的来源说明
                  </div>
                </div>

                <!-- 数据分析部分的方法介绍和查询功能 -->
                <div v-if="activeSection === 'analysis'" class="space-y-6">
                  <!-- 方法介绍 -->
                  <div class="space-y-4">
                    <h3 class="text-lg font-semibold text-gray-900 mb-3">方法介绍</h3>
                    <p class="text-gray-600 leading-relaxed">
                      {{ currentPlanState[activeSection]?.methodIntro || '您可以使用下方的查询功能了解具体统计方法的详细信息。' }}
                    </p>
                  </div>

                  <!-- 统计方法查询 -->
                  <div class="bg-gray-50 p-6 rounded-lg">
                    <h3 class="text-lg font-semibold text-gray-900 mb-4">统计方法查询</h3>
                    <div class="flex space-x-4">
                      <input
                        v-model="statisticalMethodQuery"
                        type="text"
                        placeholder="输入统计方法名称，如：t检验、方差分析、回归分析等"
                        class="flex-1 px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-purple-500"
                        @keyup.enter="queryStatisticalMethod"
                      />
                      <button
                        @click="queryStatisticalMethod"
                        :disabled="isQuerying"
                        class="px-6 py-2 bg-purple-600 text-white rounded-lg hover:bg-purple-700 transition-colors disabled:opacity-50 disabled:cursor-not-allowed flex items-center space-x-2"
                      >
                        <svg v-if="isQuerying" class="animate-spin h-5 w-5" fill="none" viewBox="0 0 24 24">
                          <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                          <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                        </svg>
                        <span>{{ isQuerying ? '查询中...' : '查询' }}</span>
                      </button>
                    </div>
                    
                    <!-- 查询结果 -->
                    <div v-if="statisticalMethodResult" class="mt-4">
                      <div class="bg-white p-4 rounded-lg shadow-sm">
                        <div class="prose prose-sm max-w-none" v-html="renderedStatisticalMethodResult"></div>
                      </div>
                    </div>
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </main>
  </div>
</template>

<script setup>
import { ref, watch, computed, onMounted } from 'vue'
import { useRouter } from 'vue-router'
import ChatBox from '../components/ChatBox.vue'
import { sendMessage, chatState } from '../stores/chatStore'
import { papersState, addHistoryPlan, historyState, clearCurrentViewingPlan, currentPlanState, updateCurrentPlan, applyPlanAsCurrentPlan, updateSourceIntroduction, getSourceIntroduction, clearSourceIntroductions } from '../stores/chatStore'
import { marked } from 'marked'

const router = useRouter()
const currentSection = ref('research-plan')
const activeSection = ref('full')
const chatBoxRef = ref(null)
const isGenerating = ref(false)
const lastMessageIdBeforeGenerate = ref(null) // 记录开始生成前的最后一条消息ID
const isViewingHistoryPlan = ref(false) // 是否正在查看历史方案
const originalPlan = ref(null) // 保存原始方案数据
const lastProcessedMessageId = ref(null) // 记录最后处理的消息ID，防止重复解析
const isEvaluating = ref(false) // 是否正在评估方案
const isIterating = ref(false) // 是否正在迭代方案
const statisticalMethodQuery = ref('') // 统计方法查询输入
const statisticalMethodResult = ref('') // 统计方法查询结果
const isQuerying = ref(false) // 是否正在查询统计方法
const isGeneratingSource = ref(false) // 是否正在生成来源介绍

const sections = [
  { id: 'full', name: '完整方案' },
  { id: 'hypothesis', name: '研究假设' },
  { id: 'design', name: '实验设计' },
  { id: 'analysis', name: '数据分析' },
  { id: 'results', name: '结果呈现' }
]

// 检测是否有AI生成的研究方案数据
const hasGeneratedPlan = computed(() => {
  // 如果正在查看历史方案，直接返回true
  if (isViewingHistoryPlan.value) {
    return true
  }
  
  // 使用全局状态的isGenerated标记
  return currentPlanState.isGenerated
})

// 配置marked选项
marked.setOptions({
  breaks: true, // 支持换行
  gfm: true,    // 支持GitHub flavored markdown
  headerIds: false, // 禁用header id生成
  mangle: false, // 禁用邮箱混淆
  pedantic: false, // 使用更宽松的markdown解析
  sanitize: false // 允许HTML（在受控环境中使用）
})

// 安全的markdown渲染函数
const safeMarkdownRender = (text) => {
  try {
    return marked(text || '')
  } catch (error) {
    console.error('Markdown渲染错误:', error)
    return text || '' // 如果渲染失败，返回原始文本
  }
}

// Markdown渲染计算属性
const renderedHypotheses = computed(() => {
  if (!currentPlanState.hypotheses || currentPlanState.hypotheses.length === 0) {
    return []
  }
  return currentPlanState.hypotheses.map(hypothesis => safeMarkdownRender(hypothesis))
})

const renderedExperimentalDesign = computed(() => {
  return currentPlanState.experimentalDesign ? safeMarkdownRender(currentPlanState.experimentalDesign) : ''
})

const renderedAnalysisMethod = computed(() => {
  return currentPlanState.analysisMethod ? safeMarkdownRender(currentPlanState.analysisMethod) : ''
})

const renderedExpectedResults = computed(() => {
  return currentPlanState.expectedResults ? safeMarkdownRender(currentPlanState.expectedResults) : ''
})

// 统计方法查询结果的Markdown渲染
const renderedStatisticalMethodResult = computed(() => {
  return statisticalMethodResult.value ? safeMarkdownRender(statisticalMethodResult.value) : ''
})

// 当前部分的来源介绍
const currentSourceIntroduction = computed(() => {
  return getSourceIntroduction(activeSection.value)
})

// 来源介绍的Markdown渲染
const renderedSourceIntroduction = computed(() => {
  return currentSourceIntroduction.value ? safeMarkdownRender(currentSourceIntroduction.value) : ''
})

// 监听活动部分变化，清空统计方法查询结果
watch(() => activeSection.value, () => {
  statisticalMethodResult.value = ''
})

// 监听sourceIntroductions的变化
watch(() => currentPlanState.sourceIntroductions, (newValue, oldValue) => {
  console.log('sourceIntroductions已更新')
}, { deep: true })

// 监听isViewingHistoryPlan的变化
watch(() => isViewingHistoryPlan.value, (newValue, oldValue) => {
  console.log('isViewingHistoryPlan状态变化:', oldValue, '->', newValue)
  if (newValue) {
    console.log('开始查看历史方案，当前sourceIntroductions:', currentPlanState.sourceIntroductions)
  } else {
    console.log('退出历史方案查看，当前sourceIntroductions:', currentPlanState.sourceIntroductions)
  }
})

// 监听方案生成完成，自动为支持的部分生成来源介绍
watch(() => currentPlanState.isGenerated, async (newValue, oldValue) => {
  if (newValue && !oldValue && papersState.referencedPapersList.size > 0) {
    console.log('检测到方案生成完成，准备自动生成来源介绍')
    
    // 延迟一下确保方案数据已经完全更新
    setTimeout(async () => {
      const sectionsToGenerate = ['hypothesis', 'design', 'results']
      
      for (const section of sectionsToGenerate) {
        // 检查该部分是否有内容
        let hasContent = false
        switch (section) {
          case 'hypothesis':
            hasContent = currentPlanState.hypotheses && currentPlanState.hypotheses.length > 0
            break
          case 'design':
            hasContent = !!currentPlanState.experimentalDesign
            break
          case 'results':
            hasContent = !!currentPlanState.expectedResults
            break
        }
        
        if (hasContent) {
          console.log(`自动为${section}部分生成来源介绍`)
          // 临时切换到该部分
          const originalSection = activeSection.value
          activeSection.value = section
          
          try {
            await generateSourceIntroduction()
            console.log(`${section}部分来源介绍生成完成`)
          } catch (error) {
            console.error(`${section}部分来源介绍生成失败:`, error)
          }
          
          // 恢复原来的部分
          activeSection.value = originalSection
          
          // 在生成之间添加延迟，避免API限制
          await new Promise(resolve => setTimeout(resolve, 2000))
        }
      }
      
      console.log('所有支持部分的来源介绍生成完成')
    }, 1000)
  }
})

// 监听聊天消息，解析研究方案
watch(() => chatState.messages, (newMessages) => {
  // 获取最新的助手消息
  const latestAssistantMessage = newMessages
    .filter(msg => msg.type === 'assistant' && msg.isComplete && !msg.isError)
    .pop()
  
  if (latestAssistantMessage) {
    // 防止重复处理同一条消息
    if (lastProcessedMessageId.value === latestAssistantMessage.id) {
      console.log('跳过重复处理的消息，ID:', latestAssistantMessage.id)
      return
    }
    
    const content = latestAssistantMessage.content
    
    // 检查是否包含研究方案Markdown格式
    const hasResearchPlanMarkdown = content.includes('研究假设') || 
                                   content.includes('实验设计') || 
                                   content.includes('数据分析') ||
                                   content.includes('结果呈现') ||
                                   (content.includes('#') && (content.includes('假设') || content.includes('设计') || content.includes('分析')))
    
    // 检查是否是评估消息或者正在评估状态
    const isEvaluationMessage = content.includes('逻辑性') && 
                               content.includes('合理性') && 
                               content.includes('可行性')
    
    // 如果是评估消息，重置评估状态并跳过方案解析
    if (isEvaluationMessage) {
      console.log('检测到评估消息，重置评估状态')
      isEvaluating.value = false
      return
    }
    
    // 如果正在评估状态，跳过方案解析
    if (isEvaluating.value) {
      console.log('处于评估状态，跳过方案解析')
      return
    }
    
    // 如果正在生成状态或迭代状态，按原有逻辑处理
    if (isGenerating.value || isIterating.value) {
      // 检查消息ID，只处理在生成开始之后的新消息
      if (lastMessageIdBeforeGenerate.value && latestAssistantMessage.id <= lastMessageIdBeforeGenerate.value) {
        console.log('跳过生成开始前的旧消息，消息ID:', latestAssistantMessage.id, '生成前最后消息ID:', lastMessageIdBeforeGenerate.value)
        return
      }
      
      console.log('收到新的助手消息（生成状态），尝试解析:', content.substring(0, 200))
      console.log('消息ID:', latestAssistantMessage.id, '生成前最后消息ID:', lastMessageIdBeforeGenerate.value)
      
      const wasSuccessfullyParsed = parseResearchPlanResponse(content)
      
      // 如果成功解析了方案，标记消息为已处理
      if (wasSuccessfullyParsed) {
        lastProcessedMessageId.value = latestAssistantMessage.id
        console.log('成功解析方案，标记消息为已处理，ID:', latestAssistantMessage.id)
        // 状态重置在parseResearchPlanResponse函数中处理
      }
      
      // 检查消息是否包含研究方案相关内容
      const hasResearchContent = hasResearchPlanMarkdown || 
                                (content.includes('研究') || content.includes('方案') || content.includes('实验'))
      
      // 如果是问候语或者非研究方案消息，继续等待
      if (!hasResearchContent && (content.includes('你好') || content.includes('助手') || content.length < 100)) {
        console.log('收到问候语，继续等待研究方案消息...')
        // 设置一个较长的超时，如果30秒内没有收到方案消息则重置状态
        setTimeout(() => {
          if (isGenerating.value) {
            console.log('等待研究方案消息超时，重置生成状态')
            isGenerating.value = false
          }
        }, 30000)
        return
      }
      
      // 如果包含研究方案内容但解析失败，也要重置生成状态（避免卡住）
      if (hasResearchContent && !wasSuccessfullyParsed) {
        console.log('包含研究内容但解析失败，重置生成状态')
        isGenerating.value = false
      }
    }
    // 如果不是生成状态，但检测到研究方案Markdown格式，也要解析
    else if (hasResearchPlanMarkdown) {
      console.log('检测到普通聊天中的研究方案回复，尝试解析:', content.substring(0, 200))
      
      // 检查是否为新消息，避免重复解析
      const messageId = latestAssistantMessage.id
      
      if (lastProcessedMessageId.value && messageId <= lastProcessedMessageId.value) {
        console.log('跳过已解析的消息，ID:', messageId)
        return
      }
      
      const wasSuccessfullyParsed = parseResearchPlanResponse(content)
      
      if (wasSuccessfullyParsed) {
        // 记录已解析的消息ID
        lastProcessedMessageId.value = messageId
        console.log('成功解析普通聊天中的研究方案，消息ID:', messageId)
      }
    }
  }
}, { deep: true })

// 解析智能体返回的研究方案Markdown
const parseResearchPlanResponse = (content) => {
  try {
    console.log('解析智能体回复，长度:', content.length, '前500字符:', content.substring(0, 500))
    
    // 预检查：跳过普通问候语和不包含研究方案的消息
    if (!content || typeof content !== 'string') {
      console.log('消息内容为空或非字符串，跳过解析')
      return false
    }
    
    // 检查是否包含研究方案相关的关键词（更宽泛的匹配）
    const hasPlanKeyword = content.includes('研究假设') || 
                          content.includes('实验设计') || 
                          content.includes('数据分析') ||
                          content.includes('结果呈现') ||
                          content.includes('#研究假设') ||
                          content.includes('#实验设计') ||
                          content.includes('#数据分析') ||
                          content.includes('#结果呈现') ||
                          (content.includes('# 研究假设')) ||
                          (content.includes('# 实验设计')) ||
                          (content.includes('# 数据分析')) ||
                          (content.includes('# 结果呈现')) ||
                          (content.includes('假设') && content.includes('实验')) ||
                          (content.includes('设计') && content.includes('方案')) ||
                          (content.includes('分析') && content.includes('方法'))
    
    // 如果是简单的问候语或不包含研究方案相关内容，跳过解析
    if (!hasPlanKeyword && (
      content.includes('你好') || 
      content.includes('助手') || 
      content.includes('帮助') ||
      content.length < 50  // 太短的消息通常是问候语
    )) {
      console.log('检测到问候语或无关消息，跳过解析:', content.substring(0, 100))
      return false
    }
    
    // 使用更简单且准确的解析方法
    const extractAllSections = () => {
      console.log('开始提取所有部分内容...')
      
      // 先找到所有的部分标题位置
      const sectionTitles = ['研究假设', '实验设计', '数据分析', '结果呈现']
      const sectionPositions = []
      
             sectionTitles.forEach(title => {
         // 查找各种可能的格式
         const patterns = [
           `#\\s*${title}\\s*[：:：]?\\s*$`, // # 研究假设：或 # 研究假设（行结尾）
           `#\\s*${title}\\s*[：:：]?\\s*\\n`, // # 研究假设：换行 或 # 研究假设换行
           `${title}\\s*[：:：]\\s*$`, // 研究假设：（行结尾）
           `${title}\\s*[：:：]\\s*\\n` // 研究假设：换行
         ]
         
         for (const pattern of patterns) {
           const regex = new RegExp(pattern, 'gim') // 添加m标志支持多行
           let match
           while ((match = regex.exec(content)) !== null) {
             sectionPositions.push({
               title: title,
               start: match.index,
               end: match.index + match[0].length,
               fullMatch: match[0]
             })
             console.log(`找到${title}在位置${match.index}，匹配内容: "${match[0]}"`)
             break // 只取第一个匹配
           }
         }
       })
      
      // 按位置排序
      sectionPositions.sort((a, b) => a.start - b.start)
      console.log('找到的部分位置:', sectionPositions.map(p => ({ title: p.title, start: p.start })))
      
      // 提取每个部分的内容
      const extractedSections = {}
      
      for (let i = 0; i < sectionPositions.length; i++) {
        const currentSection = sectionPositions[i]
        const nextSection = sectionPositions[i + 1]
        
        // 确定内容的起始和结束位置
        const contentStart = currentSection.end
        const contentEnd = nextSection ? nextSection.start : content.length
        
        // 提取内容
        let sectionContent = content.substring(contentStart, contentEnd).trim()
        
        // 清理内容
        sectionContent = sectionContent
          .replace(/^[：:：;\s]+/, '') // 移除开头的冒号和分号
          .replace(/[；;]+\s*$/, '') // 移除结尾的分号
          .trim()
        
        // 移除可能的markdown标记开头
        sectionContent = sectionContent.replace(/^#+\s*/, '').trim()
        
        if (sectionContent) {
          extractedSections[currentSection.title] = sectionContent
          console.log(`提取${currentSection.title}成功:`, sectionContent.substring(0, 100) + '...')
        }
      }
      
      return extractedSections
    }
    
    // 提取所有部分
    const extractedSections = extractAllSections()
    
    // 获取各个部分的内容
    const hypothesis = extractedSections['研究假设'] || ''
    const design = extractedSections['实验设计'] || ''
    const analysis = extractedSections['数据分析'] || ''
    const results = extractedSections['结果呈现'] || ''
    
    console.log('提取结果汇总:')
    console.log('- 研究假设:', hypothesis ? '✓ 已提取' : '✗ 未提取', hypothesis ? `(${hypothesis.length}字符)` : '')
    console.log('- 实验设计:', design ? '✓ 已提取' : '✗ 未提取', design ? `(${design.length}字符)` : '')
    console.log('- 数据分析:', analysis ? '✓ 已提取' : '✗ 未提取', analysis ? `(${analysis.length}字符)` : '')
    console.log('- 结果呈现:', results ? '✓ 已提取' : '✗ 未提取', results ? `(${results.length}字符)` : '')
    
    // 检查是否提取到至少一个有效内容
    const hasValidContent = hypothesis || design || analysis || results
    if (!hasValidContent) {
      console.log('未提取到任何有效的研究方案内容，原始内容前500字符：', content.substring(0, 500))
      // 输出更详细的调试信息
      console.log('尝试查找的关键词：')
      console.log('- 是否包含"研究假设":', content.includes('研究假设'))
      console.log('- 是否包含"实验设计":', content.includes('实验设计'))
      console.log('- 是否包含"数据分析":', content.includes('数据分析'))
      console.log('- 是否包含"结果呈现":', content.includes('结果呈现'))
      return false
    }
    
    // 先保存当前状态，然后清空字段
    const wasGenerated = currentPlanState.isGenerated
    
    // 对于新生成的方案，应该清空来源介绍，让用户重新生成
    // 只有在迭代现有方案时才保留来源介绍
    let shouldPreserveSourceIntroductions = false
    
    // 如果是迭代状态，保留现有的来源介绍
    if (isIterating.value) {
      shouldPreserveSourceIntroductions = true
      console.log('迭代模式：保留现有来源介绍')
    } else {
      console.log('生成新方案：清空来源介绍')
    }
    
    const existingSourceIntroductions = shouldPreserveSourceIntroductions && currentPlanState.sourceIntroductions ? 
      JSON.parse(JSON.stringify(currentPlanState.sourceIntroductions)) : {}
    
    // 清空字段并重置状态
    currentPlanState.hypotheses = []
    currentPlanState.experimentalDesign = ''
    currentPlanState.analysisMethod = ''
    currentPlanState.expectedResults = ''
    
    // 根据情况恢复或清空来源介绍
    if (shouldPreserveSourceIntroductions) {
      currentPlanState.sourceIntroductions = existingSourceIntroductions
      console.log('恢复来源介绍:', Object.keys(existingSourceIntroductions))
    } else {
      // 清空来源介绍，为新方案做准备
      clearSourceIntroductions()
      console.log('已清空来源介绍，新方案将重新生成')
    }
    
    console.log('已清空旧数据，开始更新新方案...')
    console.log('保留的来源介绍:', Object.keys(existingSourceIntroductions))
    
    // 计数实际更新的字段
    let updatedFields = 0
    
    // 更新研究假设（支持多个假设）
    if (hypothesis) {
      // 如果包含多个假设（用数字序号分隔），则分割成数组
      const hypothesesArray = hypothesis.split(/\n\d+\.|\n[•·]\s*/).filter(h => h.trim())
      if (hypothesesArray.length > 1) {
        currentPlanState.hypotheses = hypothesesArray.map(h => h.trim())
      } else {
        currentPlanState.hypotheses = [hypothesis]
      }
      // 初始化研究假设部分的来源介绍
      currentPlanState.hypothesis = {
        sourceIntro: '本研究假设基于现有文献和理论基础，结合研究目标和具体情境制定。'
      }
      console.log('更新研究假设:', currentPlanState.hypotheses)
      updatedFields++
    }
    
    // 更新实验设计
    if (design) {
      currentPlanState.experimentalDesign = design
      // 初始化实验设计部分的来源介绍
      currentPlanState.design = {
        sourceIntro: '实验设计方案参考了相关领域的经典实验范式和最新研究方法。'
      }
      console.log('更新实验设计:', design.substring(0, 100) + '...')
      updatedFields++
    }
    
    // 更新数据分析
    if (analysis) {
      currentPlanState.analysisMethod = analysis
      // 初始化数据分析部分的来源介绍和方法介绍
      currentPlanState.analysis = {
        sourceIntro: '数据分析方法基于研究目标和数据特征，采用适当的统计分析方法。',
        methodIntro: '通过以下搜索框检索具体方法的详细信息和使用指南。'
      }
      console.log('更新数据分析:', analysis.substring(0, 100) + '...')
      updatedFields++
    }
    
    // 更新结果呈现
    if (results) {
      currentPlanState.expectedResults = results
      // 初始化结果呈现部分的来源介绍
      currentPlanState.results = {
        sourceIntro: '结果呈现方式遵循学术论文的标准格式，确保研究发现清晰易懂。'
      }
      console.log('更新结果呈现:', results.substring(0, 100) + '...')
      updatedFields++
    }
    
    // 更新基本信息
    const timestamp = new Date().toLocaleString('zh-CN')
    currentPlanState.title = `基于AI智能体生成的定量研究方案`
    currentPlanState.researchQuestions = 'AI生成的研究方案'
    currentPlanState.methodology = `基于参考文献生成的研究方法 (生成时间: ${timestamp})`
    currentPlanState.dataCollection = '根据研究设计制定的数据收集方案'
    
    // 初始化完整方案部分的来源介绍
    currentPlanState.full = {
      sourceIntro: '本研究方案综合了多种研究方法和文献资源，旨在提供一个全面、科学的定量研究框架。'
    }
    
    // 如果至少更新了一个字段，就认为成功
    if (updatedFields >= 1) {
      // 设置为已生成状态
      currentPlanState.isGenerated = true
      currentPlanState.lastUpdated = new Date().toISOString()
      
      console.log(`成功更新 ${updatedFields} 个字段`)
      console.group('最终解析结果')
      console.log('研究假设:', currentPlanState.hypotheses)
      console.log('实验设计:', currentPlanState.experimentalDesign ? '已更新' : '未更新') 
      console.log('数据分析:', currentPlanState.analysisMethod ? '已更新' : '未更新')
      console.log('结果呈现:', currentPlanState.expectedResults ? '已更新' : '未更新')
      console.log('isGenerated:', currentPlanState.isGenerated)
      console.groupEnd()
      
      // 强制更新响应式状态
      const forceUpdate = {
        ...currentPlanState,
        _timestamp: Date.now() // 添加时间戳强制更新
      }
      Object.assign(currentPlanState, forceUpdate)
      
      // 自动切换到完整方案视图
      activeSection.value = 'full'
      
      // 显示成功提示
      console.log('成功解析并更新研究方案')
      
      // 使用Vue的nextTick确保DOM更新完成后再显示提示
      setTimeout(() => {
        if (isIterating.value) {
          // 迭代状态下的提示
          if (updatedFields >= 3) {
            alert('方案迭代成功！已优化研究假设、实验设计、数据分析和结果呈现四个完整部分。')
          } else if (updatedFields >= 2) {
            alert(`方案迭代成功！已优化 ${updatedFields} 个部分，请查看各个板块的内容。`)
          } else {
            alert('方案迭代成功！请查看右侧内容。')
          }
        } else if (isGenerating.value) {
          // 生成状态下的提示
          if (updatedFields >= 3) {
            alert('研究方案生成成功！已包含研究假设、实验设计、数据分析和结果呈现四个完整部分。PDF文件可在聊天框中下载。')
          } else if (updatedFields >= 2) {
            alert(`研究方案生成成功！已包含 ${updatedFields} 个部分，请查看各个板块的内容。PDF文件可在聊天框中下载。`)
          } else {
            alert('研究方案已生成，请查看右侧内容。PDF文件可在聊天框中下载。')
          }
        }
      }, 500)
      
      // 添加到历史方案（所有成功解析的方案都添加）
      if (updatedFields >= 1) {
        console.log('准备添加到历史方案，状态:', isIterating.value ? '迭代' : isGenerating.value ? '生成' : '普通聊天')
        
        // 构建生成上下文
        const generationContext = {
          referencedPapers: Array.from(papersState.referencedPapersList).map(paper => ({
            title: paper.title,
            authors: paper.authors,
            year: paper.year,
            source: paper.source
          })),
          generationType: isIterating.value ? 'iteration' : isGenerating.value ? 'generation' : 'chat',
          timestamp: new Date().toISOString()
        }
        
        addHistoryPlan(currentPlanState, generationContext)
        console.log('已添加到历史方案')
      }
      
      // 如果是生成状态，重置生成状态
      if (isGenerating.value) {
        console.log('方案解析完成，重置生成状态')
        isGenerating.value = false
      }
      
      // 如果是迭代状态，重置迭代状态
      if (isIterating.value) {
        console.log('方案迭代完成，重置迭代状态')
        isIterating.value = false
      }
      
      return true // 成功解析并更新了研究方案
    } else {
      console.log('未更新任何字段，解析失败')
      return false
    }
  } catch (error) {
    console.error('解析研究方案时出现意外错误:', error)
    console.log('原始内容:', content)
    return false
  }
}

// 生成定量研究方案
const generateResearchPlan = async () => {
  // 记录当前最新的消息ID
  const latestMessage = chatState.messages
    .filter(msg => msg.isComplete)
    .pop()
  lastMessageIdBeforeGenerate.value = latestMessage ? latestMessage.id : 0
  
  // 清除之前的解析记录，确保新生成的方案能被解析
  lastProcessedMessageId.value = null
  
  isGenerating.value = true
  
  console.log('开始生成新方案，当前最新消息ID:', lastMessageIdBeforeGenerate.value)
  
  try {
    // 构建消息内容
    let message = "请帮我生成定量实验方案。"
    
    // 获取所有参考文献信息（包括搜索和推荐的）
    const referencedPapers = Array.from(papersState.referencedPapersList)
    
    if (referencedPapers.length > 0) {
      message += "\n\n我将为你提供以下参考文献的内容：\n"
      
      // 为每篇论文获取研究方法和摘要
      const paperContents = await Promise.all(referencedPapers.map(async (paper, index) => {
        let paperInfo = `\n${index + 1}. 标题：${paper.title}`
        paperInfo += `\n   作者：${Array.isArray(paper.authors) ? paper.authors.join(', ') : paper.authors || '未知'}`
        paperInfo += `\n   年份：${paper.year || '未知'}`
        paperInfo += `\n   来源：${paper.source === 'search' ? '文献搜索' : 'AI推荐'}`
        
        // 如果已有摘要，直接使用
        if (paper.abstract || paper.summary) {
          paperInfo += `\n   摘要：${paper.abstract || paper.summary}`
        }
        
        // 如果已有研究方法，直接使用
        if (paper.researchMethod) {
          paperInfo += `\n   研究方法：${paper.researchMethod}`
        }
        // 如果没有研究方法但有全文，尝试获取研究方法
        else if (paper.fullText) {
          try {
            const response = await fetch('/api/paper/generate-method-summary', {
              method: 'POST',
              headers: {
                'Content-Type': 'application/json',
              },
              body: JSON.stringify({
                title: paper.title,
                fullText: paper.fullText
              })
            });
            
            if (response.ok) {
              const result = await response.json();
              if (result.success && result.methodSummary) {
                // 更新论文对象的研究方法
                paper.researchMethod = result.methodSummary;
                paperInfo += `\n   研究方法：${result.methodSummary}`;
              }
            }
          } catch (error) {
            console.error(`获取论文"${paper.title}"研究方法失败:`, error);
          }
        }
        // 如果既没有研究方法也没有全文，尝试获取全文和研究方法
        else {
          try {
            const response = await fetch('/api/paper/get-full-content', {
              method: 'POST',
              headers: {
                'Content-Type': 'application/json',
              },
              body: JSON.stringify({
                title: paper.title,
                doi: paper.doi || null
              })
            });
            
            if (response.ok) {
              const result = await response.json();
              if (result.success) {
                // 更新论文对象的全文
                if (result.fullText) {
                  paper.fullText = result.fullText;
                }
                
                // 更新研究方法
                if (result.researchMethod) {
                  paper.researchMethod = result.researchMethod;
                  paperInfo += `\n   研究方法：${result.researchMethod}`;
                }
                // 如果没有获取到研究方法但有全文，尝试生成研究方法概要
                else if (paper.fullText) {
                  try {
                    const methodResponse = await fetch('/api/paper/generate-method-summary', {
                      method: 'POST',
                      headers: {
                        'Content-Type': 'application/json',
                      },
                      body: JSON.stringify({
                        title: paper.title,
                        fullText: paper.fullText
                      })
                    });
                    
                    if (methodResponse.ok) {
                      const methodResult = await methodResponse.json();
                      if (methodResult.success && methodResult.methodSummary) {
                        paper.researchMethod = methodResult.methodSummary;
                        paperInfo += `\n   研究方法：${methodResult.methodSummary}`;
                      }
                    }
                  } catch (methodError) {
                    console.error(`生成论文"${paper.title}"研究方法概要失败:`, methodError);
                  }
                }
              }
            }
          } catch (error) {
            console.error(`获取论文"${paper.title}"内容失败:`, error);
          }
        }
        
        return paperInfo + "\n";
      }));
      
      // 添加所有论文信息到消息中
      message += paperContents.join("");
      
      message += `\n请基于以上${referencedPapers.length}篇参考文献的内容（特别是研究方法部分）生成一个详细的定量研究方案。`
    } else {
      message += "\n\n请生成一个详细的定量研究方案。"
    }

    message += `

请严格按照以下格式返回：
#研究假设：<此处填写具体研究假设内容>；
#实验设计：<此处填写实验设计详细方案>；
#数据分析：<此处描述数据分析方法>；
#结果呈现：<此处说明结果展示形式>；

要求：
1. 如果有参考文献，请先仔细阅读链接中的完整文献内容
2. 基于文献内容生成科学严谨的研究方案
3. 必须严格按照上述格式返回,使用Markdown格式
4. plan字段中的每个部分都要详细具体`
    
    console.log('准备发送的消息:', message)
    console.log('参考文献数量:', referencedPapers.length)
    
    // 发送消息到chatbox
    await sendMessage(message)
    
    // 不在这里重置isGenerating，让它在方案解析完成后重置
    console.log('消息已发送，等待方案解析完成后重置生成状态')
    
    // 设置超时重置，防止状态一直保持为true
    setTimeout(() => {
      if (isGenerating.value) {
        console.log('生成状态超时，自动重置')
        isGenerating.value = false
      }
    }, 30000) // 30秒超时
    
  } catch (error) {
    console.error('生成研究方案失败:', error)
    // 只有在发生错误时才立即重置状态
    isGenerating.value = false
  }
}

// 页面加载时检查是否有历史方案要显示
onMounted(() => {
  if (historyState.currentViewingPlan) {
    // 延迟一点再加载，确保当前方案数据已经初始化完成
    setTimeout(() => {
      loadHistoryPlan(historyState.currentViewingPlan)
    }, 100)
  }
})

// 加载历史方案数据
const loadHistoryPlan = (historyPlan) => {
  // 保存当前方案数据（只在第一次查看历史方案时保存）
  if (!originalPlan.value && !isViewingHistoryPlan.value) {
    // 检查当前是否有生成的方案，如果有则保存，否则保存默认状态
    const currentHasGenerated = currentPlanState.isGenerated
    
    originalPlan.value = { 
      ...currentPlanState,
      _hasGeneratedPlan: currentHasGenerated, // 标记原始状态是否有生成的方案
      _originalSourceIntroductions: currentPlanState.sourceIntroductions ? 
        JSON.parse(JSON.stringify(currentPlanState.sourceIntroductions)) : {} // 保存原始来源介绍
    }
    console.log('保存原始方案数据，有生成内容:', currentHasGenerated)
  }
  
  isViewingHistoryPlan.value = true
  const fullPlan = historyPlan.fullPlan
  
  // 加载历史方案数据到当前plan
  Object.assign(currentPlanState, fullPlan)
  
  // 加载历史方案的来源介绍
  if (historyPlan.sourceIntroductions) {
    currentPlanState.sourceIntroductions = JSON.parse(JSON.stringify(historyPlan.sourceIntroductions))
    console.log('加载历史方案的来源介绍:', Object.keys(historyPlan.sourceIntroductions))
  } else {
    // 如果历史方案没有来源介绍，清空当前的来源介绍
    clearSourceIntroductions()
    console.log('历史方案没有来源介绍，已清空当前来源介绍')
  }
  
  console.log('加载历史方案:', historyPlan.title)
}

// 退出历史方案查看
const exitHistoryView = () => {
  isViewingHistoryPlan.value = false
  clearCurrentViewingPlan()
  
  // 恢复原始方案数据
  if (originalPlan.value) {
    const { _hasGeneratedPlan, _originalSourceIntroductions, ...originalData } = originalPlan.value
    Object.assign(currentPlanState, originalData)
    
    // 恢复原始的来源介绍
    if (_originalSourceIntroductions) {
      currentPlanState.sourceIntroductions = JSON.parse(JSON.stringify(_originalSourceIntroductions))
      console.log('恢复原始来源介绍:', Object.keys(_originalSourceIntroductions))
    } else {
      clearSourceIntroductions()
      console.log('原始方案没有来源介绍，已清空')
    }
    
    originalPlan.value = null
    console.log('恢复原始方案数据，原本有生成内容:', _hasGeneratedPlan)
  }
}

  // 评估研究方案
  const evaluatePlan = async () => {
    if (isEvaluating.value || !currentPlanState) return
    
    try {
      isEvaluating.value = true
      
      // 构建评估提示
      const evaluationPrompt = `请对以下研究方案进行系统评估，分别从以下三方面进行分析：
1. 逻辑性：评估研究目的、研究假设、评估指标等的前后对应关系
2. 合理性：评估各评估指标、评估工具、评估方法等是否有效且合适
3. 可行性：评估用户实验的任务量、时间、成本等是否可行

最后请总结指出方案的优点和可改进之处。

研究方案内容：
${JSON.stringify({
  title: currentPlanState.title || '定量研究方案',
  hypotheses: currentPlanState.hypotheses || [],
  experimentalDesign: currentPlanState.experimentalDesign || '',
  analysisMethod: currentPlanState.analysisMethod || '',
  expectedResults: currentPlanState.expectedResults || ''
}, null, 2)}`

      // 发送消息到对话
      await sendMessage(evaluationPrompt)
      
      // 显示提示消息
      setTimeout(() => {
        alert('评估请求已发送，请等待AI助手的评估结果。')
      }, 500)

      // 设置一个定时器，在10秒后重置评估状态
      // 这是为了防止评估状态长时间保持，即使没有收到响应也会重置
      setTimeout(() => {
        if (isEvaluating.value) {
          console.log('评估状态超时，自动重置')
          isEvaluating.value = false
        }
      }, 10000)

    } catch (error) {
      console.error('评估方案失败:', error)
      alert('评估方案失败，请重试')
      isEvaluating.value = false
    }
  }

// 迭代研究方案
const iteratePlan = async () => {
  if (isIterating.value || !currentPlanState) return

  try {
    isIterating.value = true
    
    // 在迭代开始时不保存到历史记录，而是在成功生成新方案后再保存
    // 这样可以避免重复添加到历史记录
    console.log('开始迭代方案，将在成功生成新方案后保存到历史记录')

    // 获取最近的评估消息
    const latestEvaluation = chatState.messages
      .filter(msg => msg.type === 'assistant' && msg.isComplete && !msg.isError)
      .reverse()
      .find(msg => msg.content.includes('逻辑性') && msg.content.includes('合理性') && msg.content.includes('可行性'))

    if (!latestEvaluation) {
      alert('请先进行方案评估，再进行迭代优化')
      isIterating.value = false
      return
    }

    // 构建迭代提示
    const iterationPrompt = `基于上一次的评估结果，请对研究方案进行优化和迭代。重点关注评估中指出的问题和改进建议，提供具体的优化方案。

评估结果：
${latestEvaluation.content}

当前研究方案：
${JSON.stringify({
  title: currentPlanState.title || '定量研究方案',
  hypotheses: currentPlanState.hypotheses || [],
  experimentalDesign: currentPlanState.experimentalDesign || '',
  analysisMethod: currentPlanState.analysisMethod || '',
  expectedResults: currentPlanState.expectedResults || ''
}, null, 2)}

请按照以下格式返回优化后的方案：
#研究假设：<优化后的研究假设>
#实验设计：<优化后的实验设计>
#数据分析：<优化后的数据分析方法>
#结果呈现：<优化后的结果呈现方式>

注意：
1. 重点优化评估中指出的问题部分
2. 保持方案的整体一致性
3. 确保优化后的方案更加科学严谨
4. 必须按照上述格式返回完整的优化方案`

    // 发送消息到对话
    await sendMessage(iterationPrompt)

  } catch (error) {
    console.error('迭代方案失败:', error)
    alert('迭代方案失败，请重试')
  } finally {
    // 不要在这里重置isIterating，让它保持true直到新方案生成完成
    // 新方案生成完成后会在watch函数中重置isIterating
    if (!isIterating.value) {
      isIterating.value = false
    }
  }
}

// 查询统计方法
const queryStatisticalMethod = async () => {
  if (!statisticalMethodQuery.value.trim()) {
    alert('请输入要查询的统计方法名称')
    return
  }

  isQuerying.value = true
  statisticalMethodResult.value = ''

  try {
    const response = await fetch('/api/query-statistical-method', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        method: statisticalMethodQuery.value.trim()
      })
    })

    if (!response.ok) {
      throw new Error('查询失败，请稍后重试')
    }

    const data = await response.json()
    
    if (data.success) {
      statisticalMethodResult.value = data.explanation
    } else {
      throw new Error(data.error || '查询失败，请稍后重试')
    }
  } catch (error) {
    console.error('查询统计方法失败:', error)
    alert(error.message)
  } finally {
    isQuerying.value = false
  }
}

// 生成来源介绍
const generateSourceIntroduction = async () => {
  if (isGeneratingSource.value) return
  
  // 检查是否有生成的方案
  if (!hasGeneratedPlan.value) {
    alert('请先生成研究方案，再生成来源介绍')
    return
  }
  
  // 检查是否有参考文献
  const referencedPapers = Array.from(papersState.referencedPapersList)
  if (referencedPapers.length === 0) {
    alert('请先选择参考文献，再生成来源介绍')
    return
  }
  
  isGeneratingSource.value = true
  
  try {
    // 获取当前部分的内容
    let currentSectionContent = ''
    let sectionName = ''
    
    switch (activeSection.value) {
      case 'hypothesis':
        currentSectionContent = currentPlanState.hypotheses ? currentPlanState.hypotheses.join('\n') : ''
        sectionName = '研究假设'
        break
      case 'design':
        currentSectionContent = currentPlanState.experimentalDesign || ''
        sectionName = '实验设计'
        break
      case 'results':
        currentSectionContent = currentPlanState.expectedResults || ''
        sectionName = '结果呈现'
        break
      default:
        alert('当前部分不支持生成来源介绍')
        return
    }
    
    if (!currentSectionContent.trim()) {
      alert(`当前${sectionName}部分内容为空，无法生成来源介绍`)
      return
    }
    
    // 构建参考文献信息
    let referencesInfo = ''
    for (let i = 0; i < referencedPapers.length; i++) {
      const paper = referencedPapers[i]
      referencesInfo += `\n参考文献${i + 1}：`
      referencesInfo += `\n标题：${paper.title}`
      referencesInfo += `\n摘要：${paper.abstract || paper.summary || '无摘要'}`
      
      // 获取研究方法总结
      if (paper.researchMethod) {
        referencesInfo += `\n研究方法总结：${paper.researchMethod}`
      } else {
        // 如果没有研究方法总结，尝试从缓存中获取
        try {
          const response = await fetch('/api/paper/get-cached-method', {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
            },
            body: JSON.stringify({
              title: paper.title,
              doi: paper.doi || null
            })
          })
          
          if (response.ok) {
            const result = await response.json()
            if (result.success && result.methodSummary) {
              referencesInfo += `\n研究方法总结：${result.methodSummary}`
              // 更新论文对象
              paper.researchMethod = result.methodSummary
            } else {
              referencesInfo += `\n研究方法总结：暂无`
            }
          } else {
            referencesInfo += `\n研究方法总结：暂无`
          }
        } catch (error) {
          console.error('获取研究方法总结失败:', error)
          referencesInfo += `\n研究方法总结：暂无`
        }
      }
      referencesInfo += '\n'
    }
    
    // 构建发送给Coze的提示
    const prompt = `我将为你提供一个研究方案，以及研究方案参考的一些参考文献。请分析以下研究方案的"${sectionName}"部分参考了哪些参考文献的研究方法内容，并生成一个简洁的来源介绍。

研究方案的${sectionName}部分：
${currentSectionContent}

参考文献信息：${referencesInfo}

请分析${sectionName}部分具体参考了哪些文献的哪些研究方法要素，并生成一个200-300字的来源介绍，说明：
1. 该部分主要参考了哪些文献
2. 具体借鉴了这些文献的哪些研究方法要素
3. 如何结合这些方法要素形成当前的方案设计

请用学术性的语言，简洁明了地说明来源和参考依据。`

    console.log('发送来源介绍生成请求:', prompt.substring(0, 200) + '...')
    
    // 调用Coze API
    const response = await fetch('/api/coze-chat', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        message: prompt,
        conversation_id: `source_intro_${activeSection.value}_${Date.now()}`
      })
    })
    
    if (!response.ok) {
      throw new Error('生成来源介绍失败，请稍后重试')
    }
    
    const data = await response.json()
    
    if (data.success && data.reply) {
      // 保存来源介绍到全局状态
      updateSourceIntroduction(activeSection.value, data.reply)
      console.log(`成功生成${sectionName}部分的来源介绍`)
    } else {
      throw new Error(data.error || '生成来源介绍失败')
    }
    
  } catch (error) {
    console.error('生成来源介绍失败:', error)
    alert(error.message || '生成来源介绍失败，请稍后重试')
  } finally {
    isGeneratingSource.value = false
  }
}

// 应用当前历史方案为当前方案
const applyHistoryPlan = () => {
  if (historyState.currentViewingPlan) {
    // 将当前历史方案数据保存为新的当前方案
    const currentPlan = { ...currentPlanState }
    const planId = historyState.currentViewingPlan.id
    const sourceIntroductions = historyState.currentViewingPlan.sourceIntroductions
    
    // 退出历史查看模式
    isViewingHistoryPlan.value = false
    clearCurrentViewingPlan()
    
    // 清空原始数据记录，因为现在这就是新的当前方案
    originalPlan.value = null
    
    // 使用全局方法应用方案，传递方案ID和来源介绍
    applyPlanAsCurrentPlan(currentPlan, planId, sourceIntroductions)
    
    // 不再添加到历史记录，因为这个方案已经在历史记录中了
    
    console.log('应用历史方案为当前方案，方案ID:', planId)
    alert('历史方案已应用为当前方案！')
  }
}
</script>

<style scoped>
/* 自定义滚动条样式 */
.overflow-y-auto::-webkit-scrollbar {
  width: 6px;
}

.overflow-y-auto::-webkit-scrollbar-track {
  background: #f1f1f1;
  border-radius: 3px;
}

.overflow-y-auto::-webkit-scrollbar-thumb {
  background: #c5c5c5;
  border-radius: 3px;
}

.overflow-y-auto::-webkit-scrollbar-thumb:hover {
  background: #a8a8a8;
}

/* Markdown样式增强 */
.prose {
  color: inherit !important;
}

.prose h1, .prose h2, .prose h3, .prose h4, .prose h5, .prose h6 {
  color: inherit !important;
  margin-top: 1rem !important;
  margin-bottom: 0.5rem !important;
}

.prose p {
  margin-top: 0.5rem !important;
  margin-bottom: 0.5rem !important;
  line-height: 1.6 !important;
}

.prose ul, .prose ol {
  margin-top: 0.5rem !important;
  margin-bottom: 0.5rem !important;
  padding-left: 1.5rem !important;
}

.prose li {
  margin-top: 0.25rem !important;
  margin-bottom: 0.25rem !important;
}

.prose strong {
  font-weight: 600 !important;
}

.prose em {
  font-style: italic !important;
}

.prose code {
  background-color: #f3f4f6 !important;
  padding: 0.125rem 0.25rem !important;
  border-radius: 0.25rem !important;
  font-size: 0.875em !important;
}

.prose blockquote {
  border-left: 4px solid #e5e7eb !important;
  padding-left: 1rem !important;
  margin: 1rem 0 !important;
  color: #6b7280 !important;
}
</style> 